<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0792 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC2045 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2046 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2046.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2616 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY RFC3986 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4288 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4288.xml">
<!ENTITY RFC4346 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY RFC4347 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4347.xml">
<!ENTITY RFC4944 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC5785 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5785.xml">
<!ENTITY RFC5988 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5988.xml">
<!ENTITY RFC6690 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC6763 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml">
<!ENTITY RFC7252 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7396 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7396.xml">
<!ENTITY RFC7641 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7641.xml">
<!ENTITY I-D.ietf-core-resource-directory SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-resource-directory.xml">
<!ENTITY I-D.draft-jennings-core-senml SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-jennings-core-senml-01.xml">

]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" ipr="trust200902" docName="draft-ietf-core-interfaces-04">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

    <front>
        <title>Reusable Interface Definitions for Constrained Resource Environments</title>

        <author initials="Z" surname="Shelby" fullname="Zach Shelby">
          <organization>
             ARM
          </organization>
          <address>
            <postal>
             <street>150 Rose Orchard</street>
             <city>San Jose</city>
             <code>95134</code>
             <country>FINLAND</country>
            </postal>
            <phone>+1-408-203-9434</phone>
            <email>zach.shelby@arm.com</email>
          </address>
        </author>
        
        <author fullname="Matthieu Vial" initials="M.V."
                surname="Vial">
          <organization>Schneider-Electric</organization>
          <address>
            <postal>
              <street></street>
              <city>Grenoble</city>
              <region></region>
              <code></code>
              <country>FRANCE</country>
            </postal>
            <phone>+33 (0)47657 6522</phone>
            <email>matthieu.vial@schneider-electric.com</email>
          </address>
        </author>

        <author initials="M" surname="Koster" fullname="Michael Koster">
          <organization>
             ARM
          </organization>
          <address>
            <postal>
             <street>150 Rose Orchard</street>
             <city>San Jose</city>
             <code>95134</code>
             <country>USA</country>
            </postal>
            <phone>	</phone>
            <email>michael.koster@arm.com</email>
          </address>
        </author>

  <date year="2015"/>

  <area>Internet</area>

  <workgroup>CoRE</workgroup>
  <keyword>CoRE, CoAP, Hypermedia, Web Linking, Resource Discovery</keyword>

    <abstract>
    <t>
  This document defines a set of reusable REST resource design patterns suitable for use in constrained environments, based on IETF CoRE standards for information representation and information exchange. 
    </t>
    <t>
  Interface types for Sensors, Actuators, Parameters, and resource Collections are defined using the "if" link attribute defined by CoRE Link Format <xref target="RFC6690"/>. Clients may use the "if" attribute to determine how to consume resources.
    </t>
    <t>
  Dynamic linking of state updates between resources, either on an endpoint or between endpoints, is defined with the concept of Link Bindings. We also define conditional observation attributes that work with Link Bindings or with simple CoAP Observe <xref target="RFC7641"/>.
    </t> 
    </abstract>
    </front>

    <middle>


  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <section anchor="introduction" title="Introduction">

  <t>
  IETF Standards for machine to machine communication in constrained environments describe a REST protocol and a set of related information standards that may be used to represent machine data and machine metadata in REST interfaces.. CoRE Link-format is a standard for doing Web Linking <xref target="RFC5988"/> in constrained environments. SenML is a simple data model and representation format for composite and complex structured resources. CoRE Link-Format and SenML can be used by CoAP <xref target="RFC7252"/> or HTTP servers.
  </t>
  <t>
  The discovery of resources offered by a constrained server is very important in machine-to-machine applications where there are no humans in the loop. Machine application clients must be able to adapt to different resource organizations without advance knowledge of the specific data structures hosted by each connected thing. The use of Web Linking for the description and discovery of resources hosted by constrained web servers is specified by CoRE Link Format <xref target="RFC6690"/>. CoRE Link Format additionally defines a link attribute for Interface Type ("if") that can be used to describe the REST interface of a resource, and may include a link to a description document. 
  </t>
  <t>
  This document defines a set of Link Format compatible Interface Types for some common design patterns that enable the server side composition and organization, and client side discovery and consumption, of machine resources using Web Linking. An Interface Type may describe a resource in terms of it's associated content formats, data types, URI templates, REST methods, parameters, and responses. Basic interface types are defined for sensors, actuators, and properties. A set of collection types is defined for organizing resources for discovery, and for various forms of bulk interaction with resource sets using typed embedding links. 
  </t>
  <t>
  This document introduces the concept of a Link Binding, which defines a new link relation type to create a dynamic link between resources over which to exchange state updates. Specifically, a Link Binding is a link for binding the state of 2 resources together such that updates to one are sent over the link to the other. CoRE Link Format representations are used to configure, inspect, and maintain Link Bindings. This document additionally defines a set of conditional Observe Attributes for use with Link Bindings and with the standalone CoRE Observe <xref target="RFC7641"/> method.
  </t>
  <t>
 Interface Types may be used in the composition of Function Sets and Profiles. Function Sets and Profiles are described and an example is given of a sensor and actuator device profile using Function Sets composed from the Interface Types described in this document.
  </t>
  <t>
  This document describes a set of Interface Types which are referenced by the "if" link attribute and used to implement reusable design patterns and functional abstractions. A client discovering the "if" link attribute will be able to consume resources based on its knowledge of the expected interface types. In this sense the Interface Type acts in a similar way as a Content-Format, but as a selector for a high level functional abstraction. Interface types may also be provided with hypermedia controls and affordances to drive client interaction using the principles of HATEOAS. In this case, the Interface Types serve as constructor templates for resource organization and hypermedia annotation.
  </t>
  </section>
  
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** --> 
  <section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref
  target="RFC2119"/>.</t>

  <t>This specification requires readers to be familiar with all the terms
  and concepts that are discussed in <xref target="RFC5988"/> and <xref target="RFC6690"/>. This specification makes use of the following additional terminology:</t>
  
  <t>
    <list style="hanging">
      <t hangText="Interface Type:">A resource attribute which describes the interface exposed by the resource in terms of content formats, REST methods, parameters, and other related characteristics. </t>
      <t hangText="Collection:">A resource which contains set of related resources, referenced by a list of links and optionally consisting of subresources. </t>
      <t hangText="Link Binding:">A unidirectional logical link between a source resource and a destination resource, over which state information is synchronized. </t>
      <t hangText="Resource Discovery:">The process allowing a web client to identify resources being hosted on a web server. </t>
      <t hangText="Gradual Reveal:">A REST design where resources are discovered progressively using Web Linking. </t>
      <t hangText="Function Set:">A group of well-known REST resources that provides a particular service. </t>
      <t hangText="Profile:">A group of well-known Function Sets defined by a specification. </t>
      <t hangText="Device:">An IP smart object running a web server that hosts a group of Function Set instances from a profile. </t>
      <t hangText="Service Discovery:">The process making it possible for a web client to automatically detect devices and Function Sets offered by these devices on a CoRE network. </t>
    </list>
  </t> 

  </section>
  

  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <section anchor="interface-types" title="Interface Types">
  <t>
  An Interface Type definition may describe a resource in terms of it's associated content formats, data types, URI templates, REST methods, parameters, and responses. 
  </t>
  </section>
  
  <section anchor="collections" title="Collections">
  
  <section anchor="collect-intro" title="Introduction to Collections">
  <t>
  A Collection is a resource which represents one or more related resources. Within this document, a collection refers to a collection with characteristics defined in this document. A Collection Interface Type consists of a set of links and a set of items pointed to by the links which may be sub-resources of the collection resource. The collection types described in this document are Link List, Batch, Linked Batch, and Hypermedia Collection.
  </t>
  <t>
  The links in a collection are represented in CoRE Link-Format Content-Formats including JSON and CBOR variants, and the items in the collection may be represented by senml, including JSON and CBOR variants. In general, a collection may support items of any available Content-Format.
  </t>
  <t>
  A particular resource item may be a member of more than one collection at a time by being linked to, but may only be a subresource of one collection.
  </t>
  <t>
  Some collections may have pre-configured items and links, and some collections may support dynamic creation and removal of items and links. Likewise, modification of items in some collections may be permitted, and not in others.
  </t>
  <t>
  Collections may support link embedding, which is analogous to an image tag (link) causing the image to display inline in a browser window. Resources pointed to by embedded links in collections may be interacted with using bulk operations on the collection resource. For example, performing a GET on a collection resource may return a single representation containing all of the linked resources.
  </t>
  <t>
  Links in collections may be selected for processing by a particular request by using Query Filtering as described in CoRE Link-Format <xref target="RFC6690"/>.
  </t>
  </section>
  
  <section anchor="use-cases" title="Use Cases for Collections">
  <t>
  Collections may be used to provide gradual reveal of resources on an endpoint. There may be a small set of links at the .well-known/core location, which may in turn point to other collections of resources that represent device information, device configuration, device management, and various functional clusters of resources on the device.
  </t>
  <t>    
  A collection may provide resource encapsulation, where link embedding may be used to provide a single resource with which a client may interact to obtain a set of related resource values. For example, a collection for manufacturer parameters may consist of manufacturer name, date of manufacture, location of manufacture, and serial number resources which can be read as a single senml data object.
  </t>
  <t>
  A collection may be used to group a set of like resources for bulk state update or actuation. For example, the brightness control resources of a number of luminaries may be grouped by linking to them in a collection. The collection type may support receiving a single update form a client and sending that update to each resource item in the collection.
  </t>
  <t>
  Items may be sub-resources of the collection resource. This enables updates to to multiple items in the collection to be processed together within the context of the collection resource.
  </t>
  <t>
  Items may be dynamically created in a collection along with their hyperlinks. This provides an "item factory" pattern which can serve as a resource creation mechanism for dynamic resources. This pattern is also useful for creating temporary resources for the implementation of dynamic phenomena like commands, actions, and events using REST design patterns. Item creation uses the collection Content-Format which allows specification of links and item state in a single representation.
  </t>
  </section>
  
  <section anchor="content-formats" title="Content-Formats for Collections">
  <t>
  The collection interfaces by default use CoRE Link-Format for the link representations and SenML or text/plain for representations of items. The examples given are for collections that expose resources and links in these formats. In addition, a new "collection" Content-Format is defined based on the SenML framework which represents both links and items in the collection.
  </t>
  <t>
  The choice of whether to return a representation of the links or of the items or of the collection format is determined by the accepts header option in the request. Likewise, the choice of updating link metadata or item data or the collection resource itself is determined by the Content-Format option in the header of the update request operation.
  </t>
  <t>
  The default Content-Formats for collection types described in this document are:
    <list style="hanging">
      <t hangText="Links:">application/link-format, application/link-format+json</t>
      <t hangText="Items:">application/senml+json, text/plain</t>
      <t hangText="Collection:">application/collection+senml+json</t>
    </list>
  </t>
  </section>
  
  <section anchor="links-items" title="Links and Items in Collections">
  <t>
  Links use CoRE Link-Format representation by default and may point to any resource reachable from the context of the collection. This includes absolute links and links that point to other network locations if the context of the collection allows. Links to sub-resources in the collection MUST have a path-element starting with the resource name, as per RFC3986 <xref target="RFC3986"/>. Links to resources in the global context MUST start with a root path identifier <xref target="RFC5988"/>.Links to other collections are formed per RFC3986.
  </t>
  <t>
  Examples of links:
    <list style="hanging">
      <t hangText="&lt;/sen/&gt;;if=&quot;core.lb&quot;">: Link to the /sen/ collection describing it as a core.lb type collection (Linked Batch)</t>
      <t hangText="&lt;/sen/&gt;;rel=&quot;grp&quot;">: Link to the /sen/ collection indicating that /sen/ is a member of a group in the collection in which the link appears.</t>
      <t hangText="&lt;&quot;/sen/temp&quot;&gt;;rt=&quot;temperature&quot;">: An absolute link to the resource at the path /sen/temp</t>
      <t hangText="&lt;temp&gt;;rt=&quot;temperature&quot;">: Link to the temp subresource of the collection in which this link appears.</t>
      <t hangText="&lt;temp&gt;;anchor=&quot;/sen/&quot;">: A link to the temp subresource of the collection /sen/ which is assumed not to be a subresource of the collection in which the link appears ,but is expected to be identified in the collection by resource name.</t>
    </list>
  </t>  
  <t>
  Links in the collection MAY be Read, Updated, Added, or Removed using the CoRE Link-Format or JSON Merge-Patch Content-Formats on the collection resource. Reading links uses the GET method and returns an array or list containing the link-values of all selected links. Links may be added to the collection using POST or PATCH methods. Updates to links MUST use the PATCH method and MAY use query filtering to select links for updating. The PATCH method on links MUST use the JSON Merge-Patch Content-Format (application/merge-patch+json) specified in RFC7396 <xref target="RFC7396"/> .
  </t>
  <t>
  Items in the collection SHOULD be represented using the SenML (application/senml+json) or plain text (text/plain) Content-Formats, depending on whether the representation is of a single data point or multiple data points. Items MAY be represented using any supported Content-Format.
  </t>
  <t>
  Link Embedding enables the bulk processing of items in the collection using a single operation targeting the collection resource. A subset of resources in the collection may be selected for operation using Query Filtering. Bulk Read operations using GET return a SenML representation of all selected resources. Bulk item Update operations using PUT or POST apply the payload document to all selected resource items in the collection, using a either a Batch or Group update policy. A Batch update is performed by applying the resource values in the payload document to all resources in the collection that match any resource name in the payload document. Group updates are performed by applying the payload document to each item in the collection. Group updates are indicated by the link relation type rel="grp" in the link. 
  </t>
  <t>
  The collection resource SHOULD represented using the collection+senml+json Content-Format. The Hypermedia Collection type is the only collection type which supports this representation. Reading a collection using this content-format returns a representation of the links and the items in the collection. Performing a POST operation using this Content-Format MAY create one or more new item(s) and their corresponding links in the collection. Performing a PUT operation on this resource replaces the entire set of links and items with the payload. This Content-Format is described in section <xref target="collection-format"/>. Implementations MAY provide an alternate method using POST in a Content-Format used by the items in the collection which creates a default link-value and system-assigned resource name. Such implementations MAY create sub-resources of the collection resource.
  </t>
  </section>
  
  <section anchor="queries" title="Queries on Collections">
  <t>
  Collections MAY support query filtering as defined in CoRE Link-Format <xref target="RFC6690"/>. Operations targeting either the links or the items MAY select a subset of links and items in the collection by using query filtering. The Content-Format specified in the request header selects whether links or items are targeted by the operation.
  </t>
  </section>
  
  <section anchor="observing" title="Observing Collections">
  <t>
  Resource Observation using CoAP <xref target="RFC7252"/> MAY be supported on a collection. A subset of the conditional observe parameters MAY be specified to apply. In most cases pmin and pmax are useful. Resource observation on a collection MAY report any changes of resource state in any item in the collection. Observation Responses, or notifications, SHOULD provide representations of the resources that have changed in SenML Content-Format. Notifications MAY include multiple observations of a particular resource, with SenML time stamps indicating the observation times. 
  </t>
  </section>
  
  <section anchor="hypermedia" title="Hypermedia Controls on Collections">
  <t>
  Additional Hypermedia controls may be defined to enable clients to automatically consume the collection resources. Typically, the developer may map application level semantics onto collection operations. For example, invoking an Action on an actuator may be defined as creating an Action item resource in a collection of Actions associated with the actuator, each item in the collection representing a past, current, or future action to be processed by the actuator. Removing the item could cancel any pending or curent long-running action, and removing a completed action could free up resources for new actions to be invoked. A Hypermedia control for this pattern might provide a semantic name for the action, for example "Change Brightness", and might direct the client to supply a SenML representation of parameters for the action as well as provide instructions on what method (POST) to use and how to construct the URI (the collection URI in this case) if required. An example of this hypermedia control is shown below.
  </t>
  </section>

  <section anchor="collection-types" title="Collection Types">
  <t>
  There are four collection types defined in this document:
  </t>     
    <texttable>
      <ttcol align="right">Collection Type</ttcol>
      <ttcol align="left">if=</ttcol>
      <ttcol align="left">Content-Formats</ttcol>
      
      <c>Link List</c> <c>core.ll</c> <c>link-format</c>
      <c>Batch</c> <c>core.b</c> <c>link-format, senml</c>
      <c>Linked Batch</c> <c>core.lb</c> <c>link-format, senml</c>
      <c>Hypermedia Collection</c> <c>core.hc</c> <c>link-format, senml, collection+senml</c>
      <c>Binding</c> <c>core.bnd</c> <c>link-format</c>    
    </texttable>
  <t>
  Each collection type MAY support a subset of the methods and functions described above. For the first three collection types, the methods and functions are defined in the corresponding Interface Description. The Hypermedia Collection SHOULD expose hypermedia controls to applications to indicate which methods and functions are supported.
  </t>
  </section>
    
  <section anchor="collection-format" title="The collection+senml+json Content-Format">
  <t>
  The collection+senml+json Content-Format is used to represent all of the attributes and resources of a collection in a single format. This is accomplished by extending the SenmL format by adding a links element "l". The links element is formatted as an array of links in the application/link-format+json Content-Format with the tag "l" which follows the structure of the "e" element. An example of this format is given below.
  </t>
    <figure>
    <artwork align="left"><![CDATA[

{
  "bn":"/ep/sen/"
  "e":[
    { "n": "light", "v": 123, "u": "lx" },
    { "n": "temp", "v": 27.2, "u": "degC" },
    { "n": "humidity", "v": 80, "u": "%RH" }],
  "l":[
    { "href":"/ep/sen/", "rel":"self", "if": "core.hc", "rt": "ms" },
    { "href":"light", "rt":"core.s" },
    { "href":"temp", "rt":"core.s" },
    { "href":"humidity", "rt":"core.s" }]
}

    ]]></artwork>
    </figure>  

  </section>
  
  </section>
  
  <section anchor="bindings" title="Link Bindings and Observe Attributes">
    <t>In a M2M RESTful environment, endpoints exchange the content of their resources to operate the distributed system. Beforehand, a configuration phase is necessary to determine how the resources of the different endpoints are related to each other. This can be done either automatically using discovery mechanisms or by means of human intervention and a so-called commissioning tool. In this document the abstract relationship between two resources is called a link Binding. The configuration phase necessitates the exchange of binding information so a format recognized by all CoRE endpoints is essential. This document defines a format based on the CoRE Link-Format to represent binding information along with the rules to define a binding method which is a specialized relationship between two resources. The purpose of a binding is to synchronize the content between a source resource and a destination resource. The destination resource MAY be a group resource if the authority component of the destination URI contains a group address (either a multicast address or a name that resolves to a multicast address). Since a binding is unidirectional, the binding entry defining a relationship is present only on one endpoint. The binding entry may be located either on the source or the destination endpoint depending on the binding method. The following table gives a summary of the binding methods described in more detail in <xref target="binding_methods"/>.
    </t>

    <texttable>
      <ttcol align="left">Name</ttcol>
      <ttcol align="left">Identifier</ttcol>
      <ttcol align="left">Location</ttcol>
      <ttcol align="left">Method</ttcol>

      <c>Polling</c> <c>poll</c> <c>Destination</c> <c>GET</c>
      <c>Observe</c> <c>obs</c> <c>Destination</c> <c>GET + Observe</c>
      <c>Push</c> <c>push</c> <c>Source</c> <c>PUT</c>
    </texttable>  
  
    <section anchor="binding_format" title="Format">
      <t>Since Binding involves the creation of a link between two resources, Web Linking and the CoRE Link-Format are a natural way to represent binding information. This involves the creation of a new relation type, purposely named &quot;boundto&quot;. In a Web link with this relation type, the target URI contains the location of the source resource and the context URI points to the destination resource. The Web link attributes allow a fine-grained control of the type of synchronization exchange along with the conditions that trigger an update. This specification defines the attributes below:
      </t>
        
      <texttable>
        <ttcol align="left">Attribute</ttcol>
        <ttcol align="left">Parameter</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Binding method</c> <c>bind</c> <c>xsd:string</c>
        <c>Minimum Period (s)</c> <c>pmin</c> <c>xsd:integer (>0)</c>
        <c>Maximum Period (s)</c> <c>pmax</c> <c>xsd:integer (>0)</c>
        <c>Change Step</c> <c>st</c> <c>xsd:decimal (>0)</c>    
        <c>Greater Than</c> <c>gt</c> <c>xsd:decimal</c>    
        <c>Less Than</c> <c>lt</c> <c>xsd:decimal</c>    
      </texttable>  
    
      <t>
        <list style="hanging">
          <t hangText="Bind Method:">This is the identifier of a binding method which defines the rules to synchronize the destination resource. This attribute is mandatory.</t>
          <t hangText="Minimum Period:">When present, the minimum period indicates the minimum time to wait (in seconds) before sending a new synchronization message (even if it has changed). In the absence of this parameter, the minimum period is up to the notifier.</t>
          <t hangText="Maximum Period:">When present, the maximum period indicates the maximum time in seconds between two consecutive state synchronization messages (regardless if it has changed). In the absence of this parameter, the maximum period is up to the notifier. The maximum period MUST be greater than the minimum period parameter (if present).</t>
          <t hangText="Change Step:">When present, the change step indicates how much the value of a resource SHOULD change before sending a new notification (compared to the value of the last notification). This parameter has lower priority than the period parameters, thus even if the change step has been fulfilled, the time since the last notification SHOULD be between pmin and pmax. </t>
          <t hangText="Greater Than:">When present, Greater Than indicates the upper limit value the resource value SHOULD cross before sending a new notification. This parameter has lower priority than the period parameters, thus even if the Greater Than limit has been crossed, the time since the last notification SHOULD be between pmin and pmax. </t>
          <t hangText="Less Than:">When present, Less Than indicates the lower limit value the resource value SHOULD cross before sending a new notification. This parameter has lower priority than the period parameters, thus even if the Less Than limit has been crossed, the time since the last notification SHOULD be between pmin and pmax. </t>
        </list>
      </t>
    </section>

    <section anchor="binding_methods" title="Binding methods">
    
      <t>A binding method defines the rules to generate the web-transfer exchanges that will effectively send content from the source resource to the destination resource. The description of a binding method must define the following aspects:
      </t>
        
      <t>
        <list style="hanging">
          <t hangText="Identifier:">This is value of the &quot;bind&quot; attribute used to identify the method.</t>
          <t hangText="Location:">This information indicates whether the binding entry is stored on the source or on the destination endpoint.</t>
          <t hangText="REST Method:">This is the REST method used in the Request/Response exchanges.</t>
          <t hangText="Conditions:">A binding method definition must state how the condition attributes of the abstract binding definition are actually used in this specialized binding.</t>
        </list>               
      </t>
            
      <t>This specification supports 3 binding methods described below.
      </t>
      
      <t>
        <list style="hanging">
          <t hangText="Polling:">The Polling method consists of sending periodic GET requests from the destination endpoint to the source resource and copying the content to the destination resource. The binding entry for this method MUST be stored on the destination endpoint. The destination endpoint MUST ensure that the polling frequency does not exceed the limits defined by the pmin and pmax attributes of the binding entry. The copying process MAY filter out content from the GET requests using value-based conditions (e.g Change Step, Less Than, Greater Than).</t>
          
          <t hangText="Observe:">The Observe method creates an observation relationship between the destination endpoint and the source resource. On each notification the content from the source resource is copied to the destination resource. The creation of the observation relationship requires the CoAP Observation mechanism <xref target="RFC7641"/> hence this method is only permitted when the resources are made available over CoAP. The binding entry for this method MUST be stored on the destination endpoint. The binding conditions are mapped as query string parameters (see <xref target="observation"/>).</t>

          <t hangText="Push:">When the Push method is assigned to a binding, the source endpoint sends PUT requests to the destination resource when the binding condition attributes are satisfied for the source resource. The source endpoint MUST only send a notification request if the binding conditions are met. The binding entry for this method MUST be stored on the source endpoint.</t>
        </list>               
      </t>
    </section>

    <section anchor="binding_table" title="Binding table">
      <t>The binding table is a special resource that gives access to the bindings on a endpoint. A binding table resource MUST support the Binding interface defined in <xref target="binding_interface"/>. A profile SHOULD allow only one resource table per endpoint.
      </t>
    </section>
    
    <section anchor="observation" title="Resource Observation Attributes">
    
      <t>When resource interfaces following this specification are made available over CoAP, the CoAP Observation mechanism <xref target="RFC7641"/> MAY be used to observe any changes in a resource, and receive asynchronous notifications as a result. In addition, a set of query string parameters are defined here to allow a client to control how often a client is interested in receiving notifications and how much a resource value should change for the new representation to be interesting. These query parameters are described in the following table. A resource using an interface description defined in this specification and marked as Observable in its link description SHOULD support these observation parameters. The Change Step parameter can only be supported on resources with an atomic numeric value.
      </t>
      <t>These query parameters MUST be treated as resources that are read using GET and updated using PUT, and MUST NOT be included in the Observe request. Multiple parameters MAY be updated at the same time by including the values in the query string of a PUT. Before being updated, these parameters have no default value.
      </t>
      
    <texttable>
      <ttcol align="left">Resource</ttcol>
      <ttcol align="left">Parameter</ttcol>
      <ttcol align="left">Data Format</ttcol>

      <c>Minimum Period</c> <c>/{resource}?pmin</c> <c>xsd:integer (>0)</c>
      <c>Maximum Period</c> <c>/{resource}?pmax</c> <c>xsd:integer (>0)</c>
      <c>Change Step</c> <c>/{resource}?st</c> <c>xsd:decimal (>0)</c>
      <c>Less Than</c> <c>/{resource}?lt</c> <c>xsd:decimal</c>
      <c>Greater Than</c> <c>/{resource}?gt</c> <c>xsd:decimal</c>
    
    </texttable>  
    
  <t>
    <list style="hanging">
          <t hangText="Minimum Period:">When present, the minimum period indicates the minimum time to wait (in seconds) before sending a new synchronization message (even if it has changed). In the absence of this parameter, the minimum period is up to the notifier.</t>
          <t hangText="Maximum Period:">When present, the maximum period indicates the maximum time in seconds between two consecutive state synchronization messages (regardless if it has changed). In the absence of this parameter, the maximum period is up to the notifier. The maximum period MUST be greater than the minimum period parameter (if present).</t>
          <t hangText="Change Step:">When present, the change step indicates how much the value of a resource SHOULD change before sending a new notification (compared to the value of the last notification). This parameter has lower priority than the period parameters, thus even if the change step has been fulfilled, the time since the last notification SHOULD be between pmin and pmax. </t>
          <t hangText="Greater Than:">When present, Greater Than indicates the upper limit value the resource value SHOULD cross before sending a new notification. This parameter has lower priority than the period parameters, thus even if the Greater Than limit has been crossed, the time since the last notification SHOULD be between pmin and pmax. </t>
          <t hangText="Less Than:">When present, Less Than indicates the lower limit value the resource value SHOULD cross before sending a new notification. This parameter has lower priority than the period parameters, thus even if the Less Than limit has been crossed, the time since the last notification SHOULD be between pmin and pmax. </t>
    </list>
  </t>    
    
    </section>
    
  </section>
  
  <section anchor="interfaces" title="Interface Descriptions">

  <t>This section defines REST interfaces for Link List, Batch, Sensor, Parameter, Actuator and Binding table resources. Variants such as Linked Batch or Read-Only Parameter are also presented. Each type is described along with its Interface Description attribute value and valid methods. These are defined for each interface in the table below. These interfaces can support plain text and/or SenML Media types. </t>
  
  <t>The if= column defines the Interface Description (if=) attribute value to be used in the CoRE Link Format for a resource conforming to that interface. When this value appears in the if= attribute of a link, the resource MUST support the corresponding REST interface described in this section. The resource MAY support additional functionality, which is out of scope for this specification. Although these interface descriptions are intended to be used with the CoRE Link Format, they are applicable for use in any REST interface definition. </t>
  
  <t>The Methods column defines the methods supported by that interface, which are described in more detail below. 
  </t>

    <texttable>
      <ttcol align="right">Interface</ttcol>
      <ttcol align="left">if=</ttcol>
      <ttcol align="left">Methods</ttcol>
      <ttcol align="left">Content-Formats</ttcol>
      
      <c>Link List</c> <c>core.ll</c> <c>GET</c> <c>link-format</c>
      <c>Batch</c> <c>core.b</c> <c>GET, PUT, POST</c> <c>link-format, senml</c>
      <c>Linked Batch</c> <c>core.lb</c> <c>GET, PUT, POST, DELETE</c> <c>link-format, senml</c>
      <c>Sensor</c> <c>core.s</c> <c>GET</c> <c>link-format, text/plain</c>
      <c>Parameter</c> <c>core.p</c> <c>GET, PUT</c> <c>link-format, text/plain</c>
      <c>Read-only Parameter</c> <c>core.rp</c> <c>GET</c> <c>link-format, text/plain</c>
      <c>Actuator</c> <c>core.a</c> <c>GET, PUT, POST</c> <c>link-format, text/plain</c>    
      <c>Binding</c> <c>core.bnd</c> <c>GET, POST, DELETE</c> <c>link-format</c>    
    </texttable>
  
  <t>The following is an example of links in the CoRE Link Format using these interface descriptions. The resource hierarchy is based on a simple profile defined in <xref target="simple-profile"/>. These links are used in the subsequent examples below.</t>
  
   <figure>
    <artwork align="left"><![CDATA[

Req: GET /.well-known/core
Res: 2.05 Content (application/link-format)
</s/>;rt="simple.sen";if="core.b",
</s/lt>;rt="simple.sen.lt";if="core.s",
</s/tmp>;rt="simple.sen.tmp";if="core.s";obs,
</s/hum>;rt="simple.sen.hum";if="core.s",
</a/>;rt="simple.act";if="core.b",
</a/1/led>;rt="simple.act.led";if="core.a",
</a/2/led>;rt="simple.act.led";if="core.a",
</d/>;rt="simple.dev";if="core.ll",
</l/>;if="core.lb",
    ]]></artwork>
    </figure>
 
    <section anchor="link-list" title="Link List">
      
      <t>The Link List interface is used to retrieve (GET) a list of resources on a web server. The GET request SHOULD contain an Accept option with the application/link-format content format; however if the resource does not support any other form of GET methods the Accept option MAY be elided. The Accept option SHOULD only include the application/link-format content format.

<!-- This use of Accept is not very clear, should probably explain this is due to this interface type being extended by Batch and Linked Batch later -->

	  The request returns a list of URI references with absolute paths to the resources as defined in CoRE Link Format. This interface is typically used with a parent resource to enumerate sub-resources but may be used to reference any resource on a web server.
      </t>

      <t>Link List is the base interface to provide gradual reveal of resources on a CoRE web server, hence the root resource of a Function Set SHOULD implement this interface or an extension of this interface.
      </t>
      
      <t>The following example interacts with a Link List /d containing Parameter sub-resources /d/name, /d/model. </t>
      
  <figure>
    <artwork align="left"><![CDATA[

Req: GET /d/ (Accept:application/link-format)
Res: 2.05 Content (application/link-format)
</d/name>;rt="simple.dev.n";if="core.p",
</d/model>;rt="simple.dev.mdl";if="core.rp"

    ]]></artwork>
    </figure>  
    
    </section>
 
    <section anchor="batch" title="Batch">
    
    <t>The Batch interface is used to manipulate a collection of sub-resources at the same time. The Batch interface type supports the same methods as its sub-resources, and can be used to read (GET), update (PUT) or apply (POST) the values of those sub-resource with a single resource representation. The sub-resources of a Batch MAY be heterogeneous, a method used on the Batch only applies to sub-resources that support it. For example Sensor interfaces do not support PUT, and thus a PUT request to a Sensor member of that Batch would be ignored. A batch requires the use of SenML Media types in order to support multiple sub-resources. </t>
    
    <t>In addition, The Batch interface is an extension of the Link List interface and in consequence MUST support the same methods.
    </t>

<!-- Should probably explain that this means doing a GET with an Accept:application/link-format will return the sub-resource links -->    
    
    <t>The following example interacts with a Batch /s/ with Sensor sub-resources /s/light, /s/temp and /s/humidity. </t>
    
  <figure>
    <artwork align="left"><![CDATA[

Req: GET /s/
Res: 2.05 Content (application/senml+json)
{"e":[
    { "n": "light", "v": 123, "u": "lx" },
    { "n": "temp", "v": 27.2, "u": "degC" },
    { "n": "humidity", "v": 80, "u": "%RH" }],
}

    ]]></artwork>
    </figure>  
    
    </section>

    <section anchor="linked-batch" title="Linked Batch">
    
    <t>The Linked Batch interface is an extension of the Batch interface. Contrary to the basic Batch which is a collection statically defined by the web server, a Linked Batch is dynamically controlled by a web client. A Linked Batch resource has no sub-resources. Instead the resources forming the batch are referenced using Web Linking <xref target="RFC5988"/> and the CoRE Link Format <xref target="RFC6690"/>. A request with a POST method and a content format of application/link-format simply appends new resource links to the collection. The links in the payload MUST reference a resource on the web server with an absolute path. A DELETE request empties the current collection of links. All other requests available for a basic Batch are still valid for a Linked Batch.</t>
    
    <t>The following example interacts with a Linked Batch /l/ and creates a collection containing /s/light, /s/temp and /s/humidity in 2 steps. </t>
    
  <figure>
    <artwork align="left"><![CDATA[

Req: POST /l/ (Content-Format: application/link-format)
</s/light>,</s/temp>
Res: 2.04 Changed 

Req: GET /l/
Res: 2.05 Content (application/senml+json)
{"e":[
   { "n": "/s/light", "v": 123, "u": "lx" },
   { "n": "/s/temp", "v": 27.2, "u": "degC" },
}

Req: POST /l/ (Content-Format: application/link-format)
</s/humidity>
Res: 2.04 Changed 

Req: GET /l/ (Accept: application/link-format)
Res: 2.05 Content (application/link-format)
</s/light>,</s/temp>,</s/humidity>

Req: GET /l/
Res: 2.05 Content (application/senml+json)
{"e":[
   { "n": "/s/light", "v": 123, "u": "lx" },
   { "n": "/s/temp", "v": 27.2, "u": "degC" },
   { "n": "/s/humidity", "v": 80, "u": "%RH" }],
}

Req: DELETE /l/
Res: 2.04 Changed

    ]]></artwork>
    </figure>  
    
    </section>

    <section anchor="hyper-collection" title="Hypermedia Collection">
      
      <t>
      The Hypermedia Collection interface MAY provide a full set of the methods and link relation types described in section <xref target="collections"/> of this document.
      </t>
      <t>The following example interacts with a Hypermedia Collection at  /act1/actions/ by creating a new resource with Parameter sub-resources newVal, tTime. The example depicts an actuation operation with a new actuator value of 86.3% and a transition time of 10 seconds. The returned location of the created resource is then read, and a response is returned which includes the remaining time for the operation to complete "rTime". Then, the operation is cancelled by sending a DELETE operation to the location of the created resource that represents the running action.</t>
      
  <figure>
    <artwork align="left"><![CDATA[

Req: POST /Act1/Actions/
Content-Format: application/collection+senml_json
Pl: [{"n":newVal", "v":86.3}, {"n":tTime", "v":10}]
Res: 2.01 Created 
Location: Action1234

Req: GET /Act1/Actions/Action1234
Accepts: application/senml+json
Res: 2.05 Content
Pl: [{"n":newVal", "v":86.3}, 
     {"n":tTime", "v":10}, 
     {"n":"rTime", "v":"8.87"}]

Req: DELETE /Act1/Actions/Action1234
Res: 2.02 Deleted

Req: GET /Act1/Actions/Action1234
Res: 4.04 Not Found

    ]]></artwork>
    </figure>  
    
    </section>
 

    <section anchor="sensor" title="Sensor">
    
    <t>The Sensor interface allows the value of a sensor resource to be read (GET). The Media type of the resource can be either plain text or SenML. Plain text MAY be used for a single measurement that does not require meta-data. For a measurement with meta-data such as a unit or time stamp, SenML SHOULD be used. A resource with this interface MAY use SenML to return multiple measurements in the same representation, for example a list of recent measurements.</t>

    <t>The following are examples of Sensor interface requests in both text/plain and application/senml+json.</t>
    
  <figure>
    <artwork align="left"><![CDATA[

Req: GET /s/humidity (Accept: text/plain)
Res: 2.05 Content (text/plain)
80

Req: GET /s/humidity (Accept: application/senml+json)
Res: 2.05 Content (application/senml+json)
{"e":[
    { "n": "humidity", "v": 80, "u": "%RH" }],
}

    ]]></artwork>
    </figure>      
    
    </section>  

    <section anchor="parameter" title="Parameter">
    
    <t>The Parameter interface allows configurable parameters and other information to be modeled as a resource. The value of the parameter can be read (GET) or update (PUT). Plain text or SenML Media types MAY be returned from this type of interface.</t>

    <t>The following example shows request for reading and updating a parameter.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET /d/name
Res: 2.05 Content (text/plain)
node5

Req: PUT /d/name (text/plain)
outdoor
Res: 2.04 Changed 

    ]]></artwork>
    </figure> 
    
    </section>

    <section anchor="readonly-parameter" title="Read-only Parameter">
    
    <t>The Read-only Parameter interface allows configuration parameters to be read (GET) but not updated. Plain text or SenML Media types MAY be returned from this type of interface.</t>

    <t>The following example shows request for reading such a parameter.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET /d/model
Res: 2.05 Content (text/plain)
SuperNode200

    ]]></artwork>
    </figure> 
    
    </section>


    <section anchor="actuator" title="Actuator">
    
    <t>The Actuator interface is used by resources that model different kinds of actuators (changing its value has an effect on its environment). Examples of actuators include for example LEDs, relays, motor controllers and light dimmers. The current value of the actuator can be read (GET) or the actuator value can be updated (PUT). In addition, this interface allows the use of POST to change the state of an actuator, for example to toggle between its possible values. Plain text or SenML Media types MAY be returned from this type of interface. A resource with this interface MAY use SenML to include multiple measurements in the same representation, for example a list of recent actuator values or a list of values to updated.</t>
 
    <t>The following example shows requests for reading, setting and toggling an actuator (turning on a led).</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET /a/1/led
Res: 2.05 Content (text/plain)
0

Req: PUT /a/1/led (text/plain)
1
Res: 2.04 Changed 

Req: POST /a/1/led (text/plain)
Res: 2.04 Changed 

Req: GET /a/1/led
Res: 2.05 Content (text/plain)
0

    ]]></artwork>
    </figure>
 
    </section>

    <section anchor="binding_interface" title="Binding">
    
    <t>The Binding interface is used to manipulate a binding table. A request with a POST method and a content format of application/link-format simply appends new bindings to the table. All links in the payload MUST have a relation type &quot;boundTo&quot;. A GET request simply returns the current state of a binding table whereas a DELETE request empties the table.</t>
 
    <t>The following example shows requests for adding, retrieving and deleting bindings in a binding table.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: POST /bnd/ (Content-Format: application/link-format)
<coap://sensor.example.com/s/light>;
  rel="boundto";anchor="/a/light";bind="obs";pmin="10";pmax="60"
Res: 2.04 Changed 

Req: GET /bnd/
Res: 2.05 Content (application/link-format)
<coap://sensor.example.com/s/light>;
  rel="boundto";anchor="/a/light";bind="obs";pmin="10";pmax="60"

Req: DELETE /bnd/
Res: 2.04 Changed

    ]]></artwork>
    </figure>
 
    </section>
    
    <section anchor="future" title="Future Interfaces">
  
    <t>It is expected that further interface descriptions will be defined in this and other specifications. 
    </t>
    
    </section>
   
    <section anchor="wadl" title="WADL Description">
    
    <t>This section defines the formal Web Application Description Langauge (WADL) definition of these CoRE interface descriptions.</t>
    
  <figure>
    <artwork align="left"><![CDATA[

<?xml version="1.0" standalone="yes"?>

<application xmlns="http://research.sun.com/wadl/2006/10"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:senml="urn:ietf:params:xml:ns:senml">

  <grammars>
    <include href="http://tools.ietf.org/html/draft-jennings-senml"/>
  </grammars>

  <doc title="CoRE Interfaces"/>

  <resource_type id="s">
    <doc title="Sensor interface type"/>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
  </resource_type>

  <resource_type id="p">
    <doc title="Parameter interfacee type"/>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
    <method href="#update"/>
  </resource_type>

  <resource_type id="rp">
    <doc title="Read-only Parameter interface type"/>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
  </resource_type> 

  <resource_type id="a">
    <doc title="Actuator interface type"/>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
    <method href="#update"/>
    <method href="#apply"/>
  </resource_type>

  <resource_type id="ll">
    <doc title="Link List interface type"/></doc>
    <method href="#listLinks"/>
  </resource_type>

  <resource_type id="b">
    <doc title="Batch of sub-resources interface type">The methods read, 
     observe, update and apply are applied to each sub-
     resource of the requested resource that supports it. Mixed 
     sub-resource types can be supported.</doc>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
    <method href="#update"/>
    <method href="#apply"/>
    <method href="#listLinks"/>
  </resource_type>

  <resource_type id="lb">
    <doc title="Linked Batch interface type">. The methods read, 
     obervableRead, update and apply are applied to each linked 
     resource of the requested resource that supports it. Mixed 
     linked resource types can be supported.</doc>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
    <method href="#update"/>
    <method href="#apply"/>
    <method href="#listLinks"/>
    <method href="#appendLinks"/>
    <method href="#clearLinks"/>
  </resource_type>

  <resource_type id="hc">
    <doc title="Hypermedia Collection interface type">.</doc>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#observe-cancel"/>
    <method href="#getattr"/>
    <method href="#setattr"/>
    <method href="#update"/>
    <method href="#apply"/>
    <method href="#listLinks"/>
    <method href="#appendLinks"/>
    <method href="#clearLinks"/>
    <method href="#updateLinks"/>
    <method href="#readCollection"/>
    <method href="#addItem"/>
  </resource_type>

  <resource_type id="bnd">
    <doc title="Binding table resource type">A modifiable list of 
    links. Each link MUST have the relation type "boundTo".</doc>
    <method href="#listLinks"/>
    <method href="#appendLinks"/>
    <method href="#clearLinks"/>
  </resource_type>
  
  <method id="read" name="GET">
    <doc>Retrieve the value of a sensor, an actuator or a parameter.
     Both HTTP and CoAP support this method.</doc>
    <request>
    </request>
    <response status="200">
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
    <response status="2.05">
      <representation mediaType="text/plain"/>
    
  <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
  </method>

  <method id="observe" name="GET">
    <doc>Observe the value of a sensor, an actuator or a parameter. 
     Only CoAP supports this method since it requires the CoRE 
     Observe mechanism.</doc>
    <request>
      <param name="observe" style="header" type="xsd:integer">
        <option value = 0/>
      </param>
    </request>
    <response status="2.05">
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
  </method>

  <method id="observe-cancel" name="GET">
    <doc>Cancel observation in progress. 
     Only CoAP supports this method since it requires the CoRE 
     Observe mechanism.</doc>
    <request>
      <param name="observe" style="header" type="xsd:integer">
        <option value = 1/>
      </param>
    </request>
    <response status="2.05">
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
  </method>

  <method id="update" name="PUT">
    <doc>Control the actuator or update a parameter with a new value 
    or command. Both HTTP and CoAP support this method.</doc>
    <request>
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>
  
  <method id="getattr" name="GET">
    <doc>Retrieve the observe attributes associated with a resource.
        Both HTTP and CoAP support this method.</doc>
    <request>
      <doc>This request MUST contain an Accept option with
      application/link-format when the resource supports
      other GET methods.</doc>
      <representation mediaType="application/link-format"/>
    </request>
    <response status="200">
      <representation mediaType="application/link-format"/>
    </response>
    <response status="2.05">
      <representation mediaType="application/link-format"/>
    </response>
  </method>

  <method id="setattr" name="PUT">
    <doc>Set the values of some or all of the observe attributes
    associated with a resource.
    Both HTTP and CoAP support this method.</doc>
    <request>
      <param name="pmin" style="query" type="xsd:integer"/>
      <param name="pmax" style="query" type="xsd:integer"/>
      <param name="lt" style="query" type="xsd:decimal"/>
      <param name="gt" style="query" type="xsd:decimal"/>
      <param name="st" style="query" type="xsd:decimal"/>
    </request>
    <response status="200">
    </response>
    <response status="2.04">
    </response>
  </method>

  <method id="apply" name="POST">
    <doc>Apply the value, if supplied, to resources. Both HTTP and CoAP 
    support this method.</doc>
    <request>
      <doc>The apply function may contain a payload to be applied.</doc>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>

  <method id="listLinks" name="GET">
    <doc>Retrieve the list of Web links associated to a resource.
     Both HTTP and CoAP support this method.</doc>
    <request>
    <doc>This request MUST contain an Accept option with 
    application/link-format when the resource supports
    other GET methods.</doc>
    </request>
    <response status="200">
      <representation mediaType="application/link-format"/>
    </response>
    <response status="2.05">
      <representation mediaType="application/link-format"/>
    </response>
  </method>

  <method id="appendLinks" name="POST">
    <doc>Append new Web links to a resource which is a collection 
    of links. Both HTTP and CoAP support this method.</doc>
    <request>
      <representation mediaType="application/link-format"/>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>

  <method id="clearLinks" name="DELETE">
    <doc>Clear all Web Links in a resource which is a collection 
    of links. Both HTTP and CoAP support this method.</doc>
    <request>
    </request>
    <response status="200"/>
    <response status="2.02"/>
  </method>
  
  <method id="updateLinks" name="PATCH">
    <doc>Update all Web Links in a resource which is a collection 
    of links. Both HTTP and CoAP support this method.</doc>
    <doc>This request MUST contain a Content-Format option with 
    application/merge-patch+json.</doc>
    <request>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>
  
    <method id="addItem" name="POST">
    <doc>Add zero or more items to the collection with their links. Both HTTP and CoAP support this method.</doc>
    <doc>This request MAY contain a Content-Format option with 
    application/collection+senml+json.</doc>
    <doc>This request MAY contain a Content-Format option with 
    application/senml+json.</doc>
    <request>
    </request>
    <response status="200"/>
    <response status="2.01"/>
  </method>

    <method id="readCollection" name="GET">
    <doc>REturn a representation of both links and items in the collection. Both HTTP and CoAP support this method.</doc>
    <doc>This request MUST contain an Accepts option with 
    application/collection+senml+json.</doc>
   <request>
    </request>
    <response status="200"/>
    <response status="2.05"/>
  </method>

</application>

  ]]></artwork>
    </figure>
    
    </section>   
   
   
  </section>


  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section anchor="function-set" title="Function Sets and Profiles">
    
    <t>This section defines how a set of REST resources can be created called a function set. A Function Set is similar to a function block in the sense that it consists of input, output and parameter resources and contains internal logic. A Function Set can have a subset of mandatory inputs, outputs and parameters to provide minimum interoperability. It can also be extended with manufacturer/user-specific resources. A device is composed of one or more Function Set instances.
    </t>
    <t>
    	An example of function sets can be found from the CoRE Resource Directory specification that defines REST interfaces for registration, group and lookup <xref target="I-D.ietf-core-resource-directory"/>. The OMA Lightweight M2M standard [REF] also defines a function set structure called an Objects that use integer path, instance and resource URI segments. OMA Objects can be defined and then registered with an OMA maintained registry [REF]. This section is simply meant as a guideline for the definition of other such REST interfaces, either custom or part of other specifications.
    </t>

    <section anchor="definition" title="Defining a Function Set">
    
      <t>In a Function Set, types of resources are defined. Each type includes a human readable name, a path template, a Resource Type for discovery, the Interface Definition and the data type and allowed values. A Function Set definition may also include a field indicating if a sub-resource is mandatory or optional.
      </t>
      
      <section anchor="path-template" title="Path template">
      
        <t>A Function Set is a container resource under which its sub-resources are organized. The profile defines the path to each resource of a Function Set in a path template. The template can contain either relative paths or absolute paths depending on the profile needs. An absolute Function Set should be located at its recommended root path on a web server, however it can be located under an alternative path if necessary (for example multi-purpose devices, gateways etc.). A relative Function Set can be instantiated as many times as needed on a web server with an arbitrary root path. However some Function Sets (e.g. device description) only make sense as singletons.
        </t>
        
        <t>The path template includes a possible index {#} parameter, and possible fixed path segments.  The index {#} allows for multiple instances of this type of resource, and can be any string. The root path and the indexes are the only variable elements in a path template. All other path segments should be fixed.
        </t>
        
      </section>

      <section anchor="resource-type" title="Resource Type">
      
        <t>Each root resource of a Function Set is assigned a Resource Type parameter, therefore making it possible to discover it. Each sub-resource of a Function Set is also assigned a Resource Type parameter. This Resource Type is used for resource discovery and is usually necessary to discover optional resources supported on a specific device. The Resource Type of a Function Set may also be used for service discovery and can be exported to DNS-SD <xref target="RFC6763"/> for example.
        </t>
        
        <t>The Resource Type parameter defines the value that should be included in the rt= field of the CoRE Link Format when describing a link to this resource. The value SHOULD be in the form &quot;namespace.type&quot; for root resources and &quot;namespace.type.subtype&quot; for sub-resources. This naming convention facilitates resource type filtering with the /.well-known/core resource. However a profile could allow mixing in foreign namespace references within a Function Set to import external references from other object models (e.g. SenML and UCUM).
        </t>
        
      </section>

      <section anchor="interface-description" title="Interface Description">
      
        <t>The Interface Description parameter defines the REST interface for that type of resource. Several base interfaces are defined in <xref target="interfaces"/> of this document. For a given profile, the Interface Description may be inferred from the Resource Type. In that case the Interface Description MAY be elided from link descriptions of resource types defined in the profile, but should be included for custom extensions to the profile.
        </t>
        
        <t>The root resource of a Function Set should provide a list of links to its sub-resources in order to offer gradual reveal of resources. The CoRE Link List interface defined in <xref target="link-list"/> offers this functionality so a root resource should support this interface or a derived interface like CoRE Batch (See <xref target="batch"/>).
        </t>
        
      </section>

      <section anchor="data-type" title="Data type">
      
        <t>The Data Type field defines the type of value (and possible range) that is returned in response to a GET for that resource or accepted with a PUT. The interfaces defined in <xref target="interfaces"/> make use of plain text and SenML Media types for the actual format of this data. A profile may restrict the list of supported content formats for the CoRE interfaces or define new interfaces with new content types.
        </t>
        
      </section>
      
    </section>
    
    <section anchor="discovery" title="Discovery">
    
      <t>A device conforming to a profile SHOULD make its resources discoverable by providing links to the resources on the path /.well-known/core as defined in <xref target="RFC6690"/>. All resources hosted on a device SHOULD be discoverable either with a direct link in /.well-known/core or by following successive links starting from /.well-known/core.
      </t>
      
      <t>The root path of a Function Set instance SHOULD be directly referenced in /.well-known/core in order to offer discovery at the first discovery stage. A device with more than 10 individual resources SHOULD only expose Function Set instances in /.well-known/core to limit the size of this resource.
      </t>
      
      <t>In addition, a device MAY register its resources to a Resource Directory using the registration interface defined in <xref target="I-D.ietf-core-resource-directory"/> if such a directory is available.
      </t>
      
    </section>

    <section anchor="versioning" title="Versioning">

      <t>A profile should track Function Set changes to avoid incompatibility issues. Evolutions in a Function Set SHOULD be backward compatible.
      </t>
    
    </section>
    
  </section>

  <section anchor="security" title="Security Considerations">
  <t> 
  An implementation of a client needs to be prepared to deal with responses to a request that differ from what is specified in this document. A server implementing what the client thinks is a resource with one of these interface descriptions could return malformed representations and response codes either by accident or maliciously. A server sending maliciously malformed responses could attempt to take advantage of a poorly implemented client for example to crash the node or perform denial of service.  
    </t>

  </section>

  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section title="IANA Considerations">

  <t>
  The interface description types defined require registration.
  </t>

  <t>
  The new link relations type "boundto" and "grp" require registration.
  </t>
  
  <!-- We need a registry for binding methods? -->
     
  </section>

<!-- **************************************************************** -->
<!--  SECTION: ACKNOWLEDGMENTS          -->
<!-- **************************************************************** -->

<section title="Acknowledgments">

<t>Acknowledgement is given to colleagues from the SENSEI project who were critical in the initial development of the well-known REST interface concept, to members of the IPSO Alliance where further requirements for interface types have been discussed, and to Szymon Sasin, Cedric Chauvenet, Daniel Gavelle and Carsten Bormann who have provided useful discussion and input to the concepts in this document. </t>

</section>

  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section title="Changelog">
  
  <t>Changes from -03 to -04
  <list style="symbols">
  	<t>Fixed tickets #385 and #386</t>
  	<t>Changed abstract and into to better describe content</t>
  	<t>Focus on Interface and not function set/profiles in intro</t>
  	<t>Changed references from draft-core-observe to RFC7641</t>
  	<t>Moved Function sets and Profiles to section after Interfaces</t>
  	<t>Moved Observe Attributes to the Link Binding section</t>
  	<t>Add a Collection section to describe the collection types</t>
  	<t>Add the Hypermedia Collection Interface Description</t>
  </list>
  </t>

  <t>Changes from -02 to -03
  <list style="symbols">
  	<t>Added lt and gt to binding format section.</t>
  	<t>Added pmin and pmax observe parameters to Observation Attributes</t>
  	<t>Changed the definition of lt and gt to limit crossing.</t>
  	<t>Added definitions for getattr and setattr to WADL.</t>
  	<t>Added getattr and setattr to observable interfaces.</t>
  	<t>Removed query parameters from Observe definition.</t>
  	<t>Added observe-cancel definition to WADL and to observable interfaces.</t>
  </list>
  </t>

  <t>Changes from -01 to -02
  <list style="symbols">
  	<t>Updated the date and version, fixed references.</t>
  	<t>Removed pmin and pmax observe parameters [Ticket #336]</t>
  </list>
  </t>

  <t>Changes from -00 to WG Document -01
  <list style="symbols">
  	<t>Improvements to the Function Set section.</t>
  </list>
  </t>

  <t>Changes from -05 to WG Document -00
  <list style="symbols">
  	<t>Updated the date and version.</t>
  </list>
  </t>

  <t>Changes from -04 to -05
  <list style="symbols">
  	<t>Made the Observation control parameters to be treated as resources rather than Observe query parameters. Added Less Than and Greater Than parameters.</t>
  </list>
  </t>

  <t>Changes from -03 to -04
  <list style="symbols">
  	<t>Draft refresh</t>
  </list>
  </t>

  <t>Changes from -02 to -03
  <list style="symbols">
  	<t>Added Bindings</t>
  	<t>Updated all rt= and if= for the new Link Format IANA rules</t>
  </list>
  </t>

  <t>Changes from -01 to -02
  <list style="symbols">
  	<t>Defined a Function Set and its guidelines.</t>
  	<t>Added the Link List interface.</t>
  	<t>Added the Linked Batch interface.</t>
  	<t>Improved the WADL interface definition.</t>
  	<t>Added a simple profile example.</t>
  </list>
  </t>

  </section>
  
    </middle>

    <back>
    <references title='Normative References'>
       &RFC6690;
       &RFC2119;
       &RFC5988;
       
    </references>

    <references title='Informative References'>
    &RFC7252;
    &I-D.ietf-core-resource-directory;
    &I-D.draft-jennings-core-senml;
    &RFC6763;
    &RFC7641;
    &RFC3986;
    &RFC7396;
       
    </references>
  
  <section anchor="simple-profile" title="Profile example">

  <t>The following is a short definition of simple profile. This simplistic profile is for use in the examples of this document.</t>

    <texttable title="List of Function Sets">
      <ttcol align="right">Function Set</ttcol>
      <ttcol align="left">Root Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      
      <c>Device Description</c> <c>/d</c> <c>simple.dev</c> <c>core.ll</c>
      <c>Sensors</c> <c>/s</c> <c>simple.sen</c> <c>core.b</c>
      <c>Actuators</c> <c>/a</c> <c>simple.act</c> <c>core.b</c>
    </texttable>

    <texttable title="Device Description Function Set">
      <ttcol align="right">Type</ttcol>
      <ttcol align="left">Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      <ttcol align="left">Data Type</ttcol>
      
      <c>Name</c> <c>/d/name</c> <c>simple.dev.n</c> <c>core.p</c> <c>xsd:string</c>
      <c>Model</c> <c>/d/model</c> <c>simple.dev.mdl</c> <c>core.rp</c> <c>xsd:string</c>
    </texttable>

    <texttable title="Sensors Function Set">
      <ttcol align="right">Type</ttcol>
      <ttcol align="left">Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      <ttcol align="left">Data Type</ttcol>
      
      <c>Light</c> <c>/s/light</c> <c>simple.sen.lt</c> <c>core.s</c> <c>xsd:decimal (lux)</c>
      <c>Humidity</c> <c>/s/humidity</c> <c>simple.sen.hum</c> <c>core.s</c> <c>xsd:decimal (%RH)</c>
      <c>Temperature</c> <c>/s/temp</c> <c>simple.sen.tmp</c> <c>core.s</c> <c>xsd:decimal (degC)</c>
    </texttable>

    <texttable title="Actuators Function Set">
      <ttcol align="right">Type</ttcol>
      <ttcol align="left">Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      <ttcol align="left">Data Type</ttcol>
      
      <c>LED</c> <c>/a/{#}/led</c> <c>simple.act.led</c> <c>core.a</c> <c>xsd:boolean</c>
    </texttable>

  </section>

    </back>

</rfc>
